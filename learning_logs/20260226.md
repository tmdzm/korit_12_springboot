# 금일 수업 목표
1. Spring Data REST 적용으로 인해 커스텀<br>
Controller 및 Service를 매우 제한적으로 사용
    - LoginController / JwtService


# SpringBoot 3-Tier Architecture
- SpringBoot 프로젝트 상에서 애플리케이션의 유지보수성과 확장성을 높이기 위해 역할을 **분리**하는 표준적인 설계 방식으로 각 계층은 고유한 책임을 가지며,<br> 
이 계층 사이를 이동할때 DTO를 통하게 된다. 

만약에 Entity class User에 id/username/password/name/address 라고 하는 field들이 있다고 가정한다. postmane을 통해서 /login 엔드포인트를 통해 `{"username":"user","password":"password"}`가  전송된다고 했을 때, 이는 Controller를 통해 들어오게 되고 이를 Repository에서 확인하게 될것이다. 그래서 UserRepository의 findByUsername(String username)을 호출해서 특정 USer 객체가 return 될것이다. 그것이 Controller를 통해서 postman의 응답창에 출력될것이다.

## 종류
1. Controller(Presentation Layer) : 클라이언트의 요청(HTTP Request)을 먼저 받는 관문 역할<br>
요청 데이터를 검증하고 비즈니스 로직을 수행하기 위해 서비스 계층을 호출하며, 최종 결과를 응답으로 반환한다.<br>
(그래서 return type이 ResponseEntity<?> 였다.)

2. Service(Business Logic Layer) : 애플리케이션의 핵심 비지니스 로직이 수행되는 곳이다. 데이터의 가공, 트랜잭션 관리, 엔티티와 DTO간의 변환등을 담당한다.
    - 원하지 않는 정보가 나오지 않게 하거나

3. Repository (Data Access Layer) : 데이터베이스에 직접 접근하는 계층. JPA를 사용했으니까 Entity 객체를 DB테이블과 매핑하고, 실제 SQL을 실행하여 데이터를 처리한다.

- 이상을 고려했을 때 postman에서 요청이 들어오면<br>
Controller에서 요청을 검증하고 -> Service 계층으로 넘겨서 특정 정보가 있는지 여부를 체크하고 -> <br>
Repository에서 가져온 다음 -> <br>
Service 계층에서 null값이 있는지, 정보 조합이 되는지 여부를 따진다음 -><br>
Controller로 보내서 올바르다면 postman에 200을 띄울것이다.

- 요청 부분
postman -> controller -> service -> repository -> db (여기까지 요청부분)<br>
-> service -> controller (여기가 응답 객체 리턴 부분) -> postmane

4. DTO(Data Transfer Objerct)
- 계층 간 데이터 이동 시 데이터베이스 엔티티(예를 들면 Car,Owner,AppUser)를 직접 노출하지 않고 DTO를 사용
    - 보안 
    - 결합도 down
    - 유효성 검사 : 클라이언트가 보내는 데이터에 대해 특정 계층에서만 필요한 검증 로직을 추가하기에 용이.
- 그래서 DTO의 경우 request 버전과 response 버전이 나뉘는 경우가 있다. 보낼때는 username/password만 있지만,
돌아올 때는 username/password/todos 혹은 cars등이 있을 수 있다.

## 3-Tier Architecture 구현(TodoList 기준)
1. build.gradle 에서 spring-data-rest를 삭제한다.
2. 루트 패키지 내에 dto, repository , entity, service 패키지를 생성한다.
3. 기존의 domain 내에 있던 .java 파일들을 각각 respository와 entitiy로 분할
4. dto 패키지 내에 TodoRequest / TodoResponse를 만들었다. record로 만든 이유는 불변객체를 생성하기위해서, java 14이후부터는 class보단 record로 만들 것이 권장된다.

```java
package com.todo.todolist.dto;

public record TodoRequest(String content) {
}

package com.todo.todolist.dto;

public record TodoResponse(Long id, String content, boolean isCompleted) {
}

```

5. service 내에 Todoservice

```java
package com.todo.todolist.service;

import com.todo.todolist.dto.TodoRequest;
import com.todo.todolist.dto.TodoResponse;
import com.todo.todolist.entity.Todo;
import com.todo.todolist.entity.User;
import com.todo.todolist.repository.TodoRepository;
import com.todo.todolist.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service // 여러개의 리포지토리를 조립해서 원하는 결과를 뽑아내게 만들어준다.
@RequiredArgsConstructor
public class TodoService {
    private final TodoRepository todoRepository;
    private final UserRepository userRepository;

    //post 요청을 하는 비지니스 로직 작성
    @Transactional // springframework
    public TodoResponse createTodo(Long userId, TodoRequest request){
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없다."));
                //orElseThrow 없으면 에러로 던짐
        
        // DTO -> entity 변환 , 근데 왜 미리 entity가 아니라 record로 시작일까
        Todo todo = new Todo(request.content(),user); // 새로운 Todo 객체를 만들었다, 만들어지면 isCompleted = false가 적용된다.
        Todo savedTodo = todoRepository.save(todo); // 레파지토리에 저장 = db에 저장
        // 이 시점까지 todo의 id는 없다. 저장하고 난 뒤 생긴다. 
        
        //저장 완료됐다는 표시를 해주는 것
        // Entity -> DTO로 변호나해서 Controller로 넘겨줄것이다.
        return new TodoResponse(savedTodo.getId(),savedTodo.getContent(),savedTodo.isCompleted());
    }


    // GET 요청을 하는 비지니스 로직 작성

    @Transactional(readOnly = true) // jakarta 아님
    public List<TodoResponse> getTodoList(){
        return todoRepository.findAll().stream()
                .map(todo -> new TodoResponse(todo.getId(),todo.getContent(),todo.isCompleted()))
                                                // stream api를 쓰는 이유는 map함수를 적용하기
                                                //map() 리스트의 요소 하나하나에 함수를 적용하게 하는 함수... 라고 한다.
                .collect(Collectors.toList());
    }

}

```

- 이상의 코드에서 다양한 repository를 field로 삼아서 메서드들을 호출한 다음, 필요한 정보들을 가공해서 TodoResponse 객체로 return 했다는 점을 확인 할 수 있다.
그 내부 로직 중에 제어문의 다수가 쓰였다는 점, Lambda expression이 쓰이고 있다는 점에서 이전 java에서의 배경지식이 요구된다는 것도 확인할 수 있다. 그리고 .map() 복습필요.

6. controller 패키지에 todoController 생성

```java
package com.todo.todolist.controller;

import com.todo.todolist.dto.TodoRequest;
import com.todo.todolist.dto.TodoResponse;
import com.todo.todolist.service.TodoService;
import lombok.RequiredArgsConstructor;
import org.apache.coyote.Response;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController // 컨트롤러임을 명시
@RequestMapping("/api/todos")
@RequiredArgsConstructor
public class TodoController {
    private final TodoService todoService;
    // todo 등록 API
    @PostMapping("/{userId}") // @RequestMapping의 주소랑 이어진다.
    public ResponseEntity<TodoResponse> addTodo(@PathVariable Long userId, @RequestBody TodoRequest request){
        TodoResponse response = todoService.createTodo(userId, request);// TodoResponse를 새로 만들어준다. 메소드를 호출해서 대입하는 용
        // 정의되는 영역(TodoService)과 호출되는 부분이 다르다.
    return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    // todo 조회 api
    //프론트 엔드와 포스트맨과 연결되는 interface 니까
    @GetMapping
    public ResponseEntity<List<TodoResponse>> getAlltodos(){
        return ResponseEntity.ok(todoService.getTodoList()); // todoList를 리턴

    }// 다수의 Todo를 엘리먼트로 가지는 리스트 '를' 엘리먼트로 가지는 객체
}

```

- 이상의 코드에서 중요한 점은 여태까지 basePath=api로 잡아놨던 부분을 controller 클래스에서 세팅해놨다는 점이다.<br>
그래서 `@RestController` 뿐만 아니라 `@RequestMapping("/api/todos")` 가 따로 존재한다.<br>
- 그리고 `@PostMapping("/{userId})`로 되어있는 부분까지 합쳤을 때, 결과적으로 localhost:8080/api/todos/{userId}라고 해석할 수 있다.
- {userId}의 {}는 endpoint 상에서 달라질 수 있는 영역을 동적으로 받아와서 addTodo() 메서드의 매개변수로 쓰겠다는 것을 의미한다.
- 그래서 이상의 경우에 사용된 애너테이션 두 개에 대해 작성한다.
    1. `@RequestBody`
        - HTTP 요청 메서드(POST,PUT,PATCH)의 요청 본문(body)에 담긴 데이터를 읽어와 SpringController 메서드의 매개변수로 연결(binding)할 때 사용. 클라이언트가 서버로 데이터를 전송할 때 주로 사용한다<br>
        즉 postman 상에서 bodu란에 작성한 내용이 addTodo() 매개변수로 사용되었다고 볼수 있다.<br>
        그리고 그 형택가 TodoRequest 자료형이었다.

        - 특징 및 작동 원리
            1. 자동 역직렬화 : 요청본문에 포함된 Json / xml 등의 데이터를 메서드 매개변수로 지정된 java 객체로 자동 변환해준다.(즉 `Requestbody` 애너테이션 덕분에 TodoRequest로 변환되었다고 볼 수 있다.)
            2. 메시지 컨버터 : Spring의 `HttpMessageConverter`가 담당하는 부분으로, Json 데이터가 들어오게 되면 Jackson 라이브러리를 사용하는 컨버터가 이를 Java 객체로 변환해 준다.
            3. 데이터 바인딩 : 요청 Body의 field 이름과 대상 Java 객체의 field 이름이 일치하면 자동으로 값이 주어진다.<br>
            즉 Json에서의 "content"와 TodoRequest의 field인 String content가 일치하기 때문에 값을 대입해줬다. 
            4. 참고 : 요청 본문이 없는 GET 요청에는 사용할 수 없으면 보통은 `POST,PUT`과 같이 데이터 전송이 필요한 요청에 사용된다.

    2. `@PathVariable`
        - 정의 및 목적 : 해당 애너테이션은 Spring Web에서 URL 경로 변수(path variable)에 있는 값을 추출하여 Controller의 메서드의 매개변수로 바인딩하는 데 사용된다. 이는 특정 리소스를 식별하거나 **조회**할때 RESTful API 디자인을 구현하는 데 있어서 핵심적인 역할을 한다.
        - 특징 및 작동 원리
            1. URL 경로 매칭 : URL 경로의 특정 부분을 변수처럼 `{id}`와 같이 표시하고, 그 변수에 할당된 실제 값을 메서드의 매개변수로 사용하게 해준다.
            2. RESTful 식별자 : 주로 개별 리소스(특정 사용자 Id나 번호 등)를 식별하기 위해 사용되면 URI(Uniform Resource Identifier)의 의미를 명확하게 만들어준다.
            3. 자동 타입 변환 : 경로에서 추출된 문자열은 메서드의 매개변수 타입(Long,Inteager,String등)에 맞게 자동 변환된다. 

## 추후 구현 목표
1. toggle 구현 : 현재 isCompleted가 false로 고정되어있는데 true로 바꾸는 기능이 빠져있다. 그러면 toggle하려면 특정 todo의 field값을 바꾸는 것이기 때문에 id 값이 필요하다.<br>
그리고 PUT 요청이나 PATCH 요청을 통해서 {"isCompleted":true}로 요청을 보내게 되면 DB에 isCompleted 컬럼의 row가 1로 바뀌어야한다. 이 기능을 처리하기 위해서 Controller에 @PutMapping("/{todoId}")와 같은 메서드가 필요할 것같다. 그리고 당연히 TodoService에서 update(blahblah)메서드가 필요하다.

2. 완료한거 말고 아예 삭제하고 싶으면 deleteTodo 쯤 되는 메서드도 있어야 한다. DELETE도 마찬가지로 하나만 지우고 싶다면 id 값이 필요하다.