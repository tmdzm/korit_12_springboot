# SpringBoot Lesson Starts !

git config user.name "깃허브아이디"<br>
git config user.email "깃허브이메일"<br>

- SpringBoot 수업 시 vscode로 md파일 정리 / intellij로 자바 코드

- push 작업도 vscode에서 할 예정

## Gradle
- build system이 2가지가 있는데 gradle과 maven
- Maven : mvn 검색할때 본 적있다. gradel리 좀 더 빠르고 유연하다.

Gradle 의 구성(config) 파일<br>
build.gradle에서 수행<br>
프로젝트의 요구 사항에 맞게 사용자가 지정 가능하며 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임 워크 등 프로젝트의 의존성에 대한 정보를

```
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.5.11-SNAPSHOT'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.temp'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
	maven { url = 'https://repo.spring.io/snapshot' }
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	annotationProcessor 'org.projectlombok:lombok'

	runtimeOnly 'com.h2database:h2'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
	useJUnitPlatform()
}

```

### build.gradle의 일반적인 파일 항목 목록
1. 플러그인 : 플러그인 블록은 프로젝트에 쓰이는 Gradle 플러그인을 정의하는 곳으로, SpringBoot 버전을 정의한다.
2. 리포지토리 : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의한다.
    - gradle이 의존성을 가지고 오기 위해 Maven Central 리포지토리를 이용했다.
3. 의존성 : 프로젝트에서 의존성을 지정
4. 태스크 : 테스트 등의 빌드 프로세스의 일부를 정의했다.

# 스프링 이니셜라이저 활룔 프로젝트 생성(Spring Initializr) - z다음 e는 원래 없다.
1. https://start.spring.io
2. 의존성
    - Spring Boot DevTools : 자동 재시작 기능을 제공하는 개발자 도구 포함 / 변경 내용을 저장할 때마다 애플리케이션이 자동 다시 실행된다.
    - Spring Boot Starter Web : 풀스택 개발을 위한 옵션으로 자체 내장 톰캣 서버를 제공한다(엣날 스프링 시절에는 server 설정을 하나하나 다 잡아줘야 했다.)

# main 단계에서의 Springboot 프로젝트의 애너테이션
1. `@EnableAutoConfiguration` : 스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성된다.(우리가 추가 설정할 필요 없이). 예를 들어서 spring-boot-starter-web의존성이 있는 경우 스프링부트는 우리가 웹 애플리케이션을 개발 중이라고 인식하고 그에 따라 애플리케이션 구성을 가진다.

2. `@ComponentScan` : 스프링부트 컴포넌트 검색으로, 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 한다

3. `@Configuration` : 빈(bean) 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정.

## 로그 및 문제해결
1. Logging은 애플리케이션의 흐름을 모니터링하는데 이용할 수 있고, 오류를 포착하는 방식이다.
스타터 패키지 내에 Logback이 존재하는데, SLF4J(simple logging facade for Java)의 축약어

2. logger.info(); 로그 메시지를 console에 출력한다.
- 로깅 수준 종류 : TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 수준이 있다.<br>
이를 `application.properties`에서 정의한다. default 수준은 info에 해당한다.<br>
Trace는 모든 세부 동작을 다 추적하는 상태로 가장 최상위 수준이다.

```
logging.level.root=INFO
```

3. port number : 8080이다. 바꿔서 쓸 수 있지만 일단 그대로 (mariaDB는 3310으로 썻다.)
    - 실행 중일 때 또 실행 버튼 눌러서 터지는 경우가 있다. 그래서 수업중에 어플리케이션 정지하라고 하면 미리 정지 해라

# 의존성 주입(Dependency Injection : DI)
- 의존성 주입은 구성 요소 간의 느슨한 결합을 이용하여 코드를 유연하고 유지 관리 및 테스트하기 쉽게 만들어주는 요인이다.

## 의존성 주입 소개
- 의존성 주입은 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발기법으로, 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지시킴.

이미지를 중심으로

- service : 클라이언트가 이용할 수 있는 클래스를 의미 - h2 database/ lombok etc
- client : 의존성을 이용하는 클래스 - Logger를 CardatabaseApplication에서 이용했다.
- Injector : 의존성을 의존클래스에 전달하는 기능 담당.

```java
public class Car{
    //필드 선언
    private Owner owner;
    //생성자 정의
    public Car() {
        owner = new Owner();
    }

}
```

이상의 코드는 클라이언트 클래스인 car가 서비스 클래스인 Owner의 객체를 생성하기 때문에 의존성 주입이 없다.<br>
(즉 직접 생성하기 때문에 요청 과정이없다.)

```java
public class Car{
    private Owner owner;
    public Car(Owner owner) {
        this.owner = owner;
    }
}
```
서비스 객체(owner)가 클라이언트 클래스(car)에서 직접 생성되징 낳고, 매개변수로 전달된다.(즉 CarMain 같은곳에서 owner 객체를 생성해서 집어넣어줘야만 한다.)

- 서비스 클래스는 추상 클래스일수도 있다.
이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에서는 모형을 이용할 수도 있다.

- 의존성 주입 방식도 여러가지가 있다.
1. 생성자 주입 : 의존성이 클라이언트 클래스 생성자에 전달되는 방식. 아까 위에 적은 방식에 해당한다. 생성자 주입은 필수 의존성에 이용하는 거싱 좋다.

2. 세터 주입(setter) : 의존성이 세터를 통해 제공<br>
예시
```java
public class Car{
    private Owner owner;
    public void setOwner(Owner owner) {
        this.owner = owner;
    }
}

public class CarMain {
    public static void main(String[] args){
        Car car1 = new Car();
        Car car2 = new Car();

        Owner owner1 = new Owner();
        car1.setOwner(owner1);
        car2.setOwner(owner1);
        //이게 의존성이 느슨한 경우,??
        //기본생성자로 만드니까 뭐
    }

}
```

즉 이상의 코드의 세터 주입은 의존성이 없더라도 일단 객체를 기본 생성자로 만들 수 있기 때문에 더 유연하다.<br>
생성자 주입의 경우 일단 Owner가 만들어져야 Car 객체를 만들 수 있다.

다시말해, 의존성 주입은 코드 자체의 의존성을 줄이고, 코드를 재사용하기 쉽게 테스트 할 수 있도록 해준다.

## SpringBoot에서의 의존성 주입 이용

- 스프링 프레임워크에서 의존성 주입은 `ApplicationContext`를 통해서 이루어진다. 이는 객체(bean)와 객체의 의존성을 생성하고 관리하는 역할을 한다.

- 스프링부트는 애플리케이션 클래스를 검색하여 특정 에너테이션이 있는 클래스를 빈으로 등록한다. 의존성 주입을 통해 빈을 주입하는게 가능하다.

- 일반적인 방법은 일단 `생성자 주입`

- 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 하므로 가장 권장되는 방식이다.<br>
가장 보편적인 상황은 특정 작업을 위해 데이터베이스에 대한 접근이 필요한 경우, 스프링부트에서는 DB에 접근하는 클래스를 `리포지토리`클래스라고 한다.

```java
public class Car{
    private final CarRepository carRepositiry; // 보통은 여기서 초기화를 해준다. 여기선 아님

    public Car(CarRepository carRepositiry){//여기선 생성자 로 초기화
        this.carRepository = carRepositiry
    }
    //다만 의문인건, Car를 생성할때 카리포지토리가 선언되면서 바로 초기화가 되는듯 한데, 문법상 뭔가 이질적인 느낌인데

    carRepository.findAll();//이게 뭐지, 데이터베이스 테이블의 모든 레코드를 조회할 때 사용하는 가장 기본적인 메서드
}
```

그런데 클래스 생성자가 여러 개 있는 경우에는 `@Autowired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야 한다.

`세터 주입` : 선택적 의존성인 경우나, 프로그램 실행중에 의존성 수정하는 경우에 사용한다.
```java
@Service
public class AppUserService {
  private AppUserRepository userRepository;

  @Autowired
  public void setAppUserRepository(AppUserRepository userRepository) {
    this.userRepository = userRepository;
  }
}
```

`필드주입` : 의존성을 필으데 직접 주입. 단순하지만 오류가 발생할 가능성 높음

```java
@Service
public class CarDatabaseService implements CarService{
    //그냥 인터페이스 있다고 가정
}

public class CarController{
    @Autowired
    private CarDatabaseService carDatabaseService;
}

```

혼란스러워 보이지만 밑과 동일하다.

```java
private CarDatabaseService carDatabaseService = new CarDatabaseService();
```

# 2월 19일 시험
1 과목 sql 활용 : 30문제 객관식 4지선다<br>
2 과목 sql 응용 : 50문제, sql 작성 15, 15, 20
DCL은 없다. 트랜잭션이나 트리거등