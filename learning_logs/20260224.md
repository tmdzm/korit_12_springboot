# RESTful API 명세서 작성
- RESTful API는 이용하는 개발자가 그 기능과 작동을 이해할 수 있도록 적절히 문서화가 되어야 한다.
그리고 그 문서에는 이용할 수 있는 엔드포인트, 허용되는 데이터 형식, API와 상호작용하는 방법 등이 포함되어야 한다.

- 현재 우리는 Spring Data REST를 적용한 상태이다.<br>
즉, 엔드포인트들이 자동생성되기 때문에 우리가 파악하지 못한 부분들이 있을 수 있어 API 명세서는 더 중요하다고 할 수 있다.

- 포스트맨 - 크리에이트 드롭 설정때문에 추가해도 남아있질 않다.

# SpringBoot의 Swagger / Open API
1. Swagger / Open API란?
  - OpenAPI Specification(OAS) : RESTful API를 설계, 구축, 문서화 하는 방법을 정의하는 표준 사양
  - Swagger : 이상의 표준 사양을 구현하여 개발자가 API구조를 시각적으로 확인하고 직접 테스트할 수 있도록 돕는 틀
  - 도입목적 : 백 - 프론트 간 협업시 별도의 문서 작성 없이 실시간으로 업데이트 되는 API 명세서를 제공하기 위함

# API란
## 정의
- Application Programming Interface
- interface란 무엇인가, 접두사 inter는 ~~사이 정도의 의미를 가지고 있다. 즉, 얼굴들 사이를 연결시켜 주는 모든것
- 서로 다른 소프트웨어가 대화할 수 있게 해주는 규칙이나 매개체
- 손님(Client) : 주문을 하는 사람(앱이나 웹사이트)
- 주방(Server) : 요리를 하는 곳(데이터나 기능을 가진 시스템)
- 점원(API)    : 손님이 주문을 주방에 전달하고, 주방에서 만든 음식을 손님에게 전달

- 이상에서의 중요한 점은 손님은 주방 안에서 어떤 일이 일어나는지(내부 로직) 알 필요가 없다는것. 점원에게 정해진 규칙대로 말하기만 하면 원하는 겨ㅑㄹ과를 얻을 수 있다.

## API의 핵심 역할
1. 전달자 : 요청을 받고 응답(response) - req / resp
2. 보안/관문 : 아무나 데이터를 가져가지 못하게 인증된 사용자만 접근을 허용함
3. 표준화 : 서로 다른 언어로 만들어진 프로그램들이 같은규칙으로 소통하게 한다.

- 우리가 만든 백엔드의 Controller 클래스가 APi의 입구가 된다.<br>
즉, Controller 클래스는 프론트엔드에서 요청이 왔을때 맨 처음 백엔드 상으로 처리하는 관문 역할을 하는 곳이라고 볼 수 있다.
- 즉, json형태로 들어온걸 다른 형태로 만들어줄 수 있는 곳

# 프로젝트 설정
1. SpringBoot 3.xx 버전에서는 `jakarta`로 써야한다.
옛날 버전은 `javax`을 쓰는경우가 있다.

```java
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.15'
```

- starter가 포함된 버전을 사용해야 오류가 안난다.
- mvn을 통할경우 openapi를 검색하면 너무 많이 나오는데
starter / webmvc 존재 유무로 체크

2. application.properties 수정
- Swagger UI의 경로와 API 문서의 기본 정보를 설정한다.
현재 우리는 Spring Data rest때문에 basepath가 '/api'이다.

```java
# Swagger UI access path config(default : /swagger-ui/index.html)
springdoc.swagger-ui.path=/swagger-ui.hmtl

# open api doc path
springdoc.api-docs.path=/api-docs

#Intergrated Configuration Spring Data REST
springdoc.show-data-rest=true
```

예를 들어 이상까지 작성했다면 http://localhost:8080/swagger-ui/index.html 로 접속했다면

![alt text](image-3.png)

이렇게 나온다.

owners인 이유 - 리스트로 잡아놔서 엔트포인트가 알아서 복수형으로 바꿔준다.

3. API 문서 상세 설정

- `@Bean` : 메서드 레벨의 애너테이션으로, Spring 컨테이너에 의해 관리되는 객체인 빈을 정의하고 등록하는 역할을 한다.

1. `@Bean`의 정의
  - 객체 등록 : 해당 메서드가 반환하는 객체를 Spring의 IoC(Inversion of Control) 컨테이너가 관리하는 빈으로 등록하도록 지시한다.
  - 설정 소스 : 보통 `@Configuration` 애너 테이션이 붙은 클래스내에서 사용되며, 이 클래스는 빈 정의를 제공하는 소스 역할을 한다.
  - 수동 등록 : 개발자가 직접 제어할 수 없는 외부 라이브러리 객체를 생성하거나, 복잡한 초기화 로직이 필요한 객체를 Spring 컨테이너에 등록할 때 사용한다.


```java
package com.korit2.cardatabase.config;


import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration // 빈 정의를 제공하는 소스 클래스라는 것을 명시
public class OpenApiConfig {
    @Bean // 메서드 리턴 객체를 Spring 빈으로 등록
    public OpenAPI cardatabaseOpenAPI(){
      //직접 OpenAPI 객체를 생성하고 커스터마이징(빌더패턴을 통해) 함
        return new OpenAPI()
                .info(new Info()
                        .title("Car Database API")
                        .description("자동차 및 소유주 관리를 위한 REST API 명세서")
                        .version("1.0.0")
                );
    }//call3 유형
}
```
- 상세 동작 고나련 추가 설명
  1. 설정 소스 인식 : 스프링부트 애플리케이션이 실행될 때 `@Configuration`이 붙은 클래스를 스캔하여 빈 정의 소스로 인식
  2. 메서드 실행 및 등록 : 클래스 내부에서 `@Bean`이 붙은 cardatabaseAPI()메서드를 Spring이 직접 호출
  3. 빈 관리 : 이상의 메서드에서 return된 OpenAPI객체는 Spring 컨테이너 내에서 보관. 해당 객체는 나중에 Swagger UI가 API 명세서를 생성할 때, 제목/ 설명 / 버전 등의 정보를 제공하는 설정 데이터(config)로 사용된다.
  4. 유지보수성 향상 : 이처럼 `@Bean`을 통해 설정 정보를 분리, 관리하면 애플리케이션의 핵심 로직과 외부 설정 라이브러리 간의 결합도를 낮추고 유연하게 변경가능

# 1번 질문에 대비한 Bean 정리
Spring 프레임워크 상에서의 빈은 **스프링의 IoC(제어의 역전) 컨테이너가 생성하고 관리하는 자바 객체**를 의미한다.

단순히 우리가 `new` 키워드를 이용하여 직접 생성하는 일반적인 객체와는 달리<br>
빈은 스프링 컨테이너에 의해 생명주기(생성,초기화,소멸)가 관리되는 것이 특징

1. 빈의 핵심 역할 : 의존성 주입
  - 빈은 `ApplicationContext`라는 컨테이너를 통해 빈을 관리하며, 객체 간의 의존성을 자동으로 연결해준다.
  - 이상을 통해 코드 간의 결합도를 낮추고 유연성을 높일 수 있다.
  - 예시 : CarDatabaseApplication 클래스에서 직접 CarRepository 객체를 생성하지 않고 field 선언을 통해서 스프링이 관리하는 빈을 주입 받아 사용했다.

    - 이상의 경우에 CarRepository carRepository = new CarRepository(); 호출한 적이 없는데 매개변수로 Spring 컨테이너에 알아서 객체 생성해서 field 주입을 했다.
2. 빈 등록 방법
  - `@Bean`은 빈을 수동으로 등록하는 방법 중 하나고, 위의 예시를 생각했을 때는<br>
  컴포넌트 스캔을 통해서 더 자주 이루어진다. 컴포넌트 스캔이란
  특정 애너테이션이 붙은 클래스를 자동으로 검색하여 빈으로 등록하는 것을 의미한다.
  - CarRepository엔 애너테이션이 없는데? - extends Jpa 자식아
    - @Component : 일반적인 컴포넌트 빈
    - @Service : 비즈니스 로직을 처리하는 서비스 클래스
    - @Repository : 데이터베이스 접근을 담당하는 리포지토리 클래스
    - @Controller / @RestController : 웹 요청을 처리하는 컨트롤러 클래스
  - 설정 클래스에서 수동 등록 : @Configuration 내부에서 @Bean이 있으면 수동 등록이 된다.

3. 빈의 특징
    1. 관리 주체 : 개발자가 아니라 스프링 컨테이너
    2. 싱글톤 원칙 : 기본적으로 스프링은 빈을 단 하나만 생성해서 애플리케이션 전체에 공유, 재사용 한다.
    3. 명명 규칙 : 빈은 고유한 이름을 가지며, 스프링은 이 이름을 통해 필요한 곳에 적절한 빈을 찾아 주입한다.

# 백엔드 보호

1. Spring Security의 이해
2. JWT(JSON Web Token)으로 백엔드 보호
3. 역할 기반 보안(Role-based Security)

## 스프링 시큐리티
- Java 기반 웹 애플리케이션을 위한 보안 서비스 제공 라이브러리.

- default 설정 값
1. 인메모리 사용자 하나를 포함하는 `AuthenticationManager` 빈.<br> username은 user, 암호는 console창에 출력된다.(마치 h2사용했을때 uri 경로가 임시적으로 발급됐던것 처럼)
2. `/css`,`/images`와 같은 일반적인 정적 리소스 위치(static)의 경로를 무시. 다른 모든 엔드포인트에 대한 HTTP에 인증을 요구
3. 스프링 자체에서의 `ApplicationEventPublisher` 인터페이스로 보호되는 보호 이벤트
4. HSTS, XSS, CSRF등 일반적인 저수준 기능을 기본적으로 활성화.
5. 자동 생성 로그인 페이지

- 의존성을 추가 할거다

![alt text](image-4.png)

- http://localhost:8080으로 접속했을때, 혹은 /api까지 해서 접속했을대 알아서 /login 엔드피온트로 넘어가면서 로그인할 것을 요구한다.

- 이는 build.gradle에 spring security를 추가했기 때문에 생겨난 것이다.

- 그런데 재실행해보면 비밀번호 바뀌어있고 또 찾아서 로그인해야하고 그런 상황이 벌어진다.<br>
username / password를 고정시키고 싶다면 스프링 시큐리티에 대한 config 클래스를 정의해야한다.<br>
해당 클래스 내에서 특정 역할이나 사용자가 접근 할 수 있는 URL 또는 URL 패턴을 정의할 수 있다. 또한 인증 메커니즘, 로그인 프로세스, 세션 관리 등도 정의할 수 있다.

- config 패키지 내에 SecurityConfig 클래스를 생성해보자

```java
package com.korit2.cardatabase.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService(){
        UserDetails user = User.builder()//빌더 패턴으로 객체생성, 즉 필드명과 값을 명시적으로 넣을 수 있다.
                .username("user")
                .password(passwordEncoder().encode("password")) // 비번 고정
                .roles("USER") // 역할 기반 보안, 일반 사용자의 경우
                .build();
        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

```

- 이상의 코드에서 `@Configuration, @EnableWebSecurity` 에너테이션은 default 웹 보호구성을 해제하고, 개발자가 직접 Config 관련 설정을 정의할 수 있도록 허용한다. 이후 수업에서 `filterChain(HttpSecurity http)` 메서드 내에서 애ㅑ플리케이션의 어떤 엔드포인트가 보호되고 있는지, 어떤 엔드포인트가 보호되고 있지 않은지 정의할 수 있다.

- filter chain은 골치아프다.
- 특정한 순서대로 작동하지 않으면 에러
- UserDetailsService(중요)를 구현하는 스프링 시큐리티의 InMemoryUserDetailsService(덜 중요)를 이용하여 애플리케이션에 인메모리 user를 추가했다(테스트용으로만 적합).<br>
메모리에 저장된 user/password 인증을 구현했다. 빌더패턴을 이용했다.

- H2에서 확인했듯 인메모리 사용자는 DB에 저장된것이 아니기 때문에 재부팅하면 초기화가 이루어진다. USer 관련 속성을 DB에 저장하고 싶다면 엔티티 클래스와 리포지토리 클래스를 정의해야만 한다. 그리고 암호는 텍스트 형식으로 DB에 저장하면 보안 문제가 생길것이다.

- AppUser 엔티티 클래스와 리포지토리 클래스를 생성하시오

- findByUsername 메서드를 정의하시오. -> 어디에 어떻게 적을지 떠올라야 한다

```java
package com.korit2.cardatabase.domain;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUser,Long> {
    Optional<AppUser> findByUsername(String username);

}


```

- 이상에서 주목해야 할 것은 여태까지 CarRepository에 추상 메서드들을 정의했을 때는 결과값들이 기볹벅으로 복수라서 List 자료형을 썼다.
- 하지만 findByUsername()의 경우 AppUser의 필드인 username이 기본적으로 결과값이 하나거나, 0개이다. 그렇기에 List는 어울리지 않는다.
- 그래서 옛날에는 NullPointException(Null만났을때 예외처리)이 발생하는 문제가 생겼었다. 이를 해결하기 위해서는

```java
public AppUSer findByUsername(String username){
  if(username이 DB내에 일치하는 username이 있다면){
    return 일치하는 객체 전체를 리턴(AppUser 자료형)
  }
  return null;
}
```

과 같은 방식으로 미리 예외처리를 해줘야 했다.<br>
그런데 Repository는 인터페이스라 일반 메서드를 만들 수 없다.(예외처리 불가)<br>
이를 해결하기 위해 `Optional`이라는 자료형이 생겼다.<br>

- Optional은 여기서 처음 배우는 자료형이다.
- Optional은 내부에 null이 있어도 예외처리가 작동하지 않는다.
- 다만, Optional 내부에 AppUser 자료형이 존재한다면, AppUser 객체를 꺼내는 별개의 메서드를 호출할 필요는 있다.

- domain과 동일한 수준에 service 패키지를 생성한다. -> 내부에 UserDetailsServiceImpl 이라는 클래스를 생성한다.

```java
package com.korit2.cardatabase.service;

import com.korit2.cardatabase.domain.AppUser;
import com.korit2.cardatabase.domain.AppUserRepository;
import lombok.AllArgsConstructor;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.User.UserBuilder;// User.UserBuilder라고 안쓰기 위해서
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Optional;

@AllArgsConstructor // final 안적어도 되게한다. 근데 오ㅑ
@Service //bean 등록이 되어있는 애너테이션
public class UserDetailsServiceImpl implements UserDetailsService { //Impl - 특별한 규칙

    //field 선언
    private AppUserRepository appUserRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = appUserRepository.findByUsername(username);

        UserBuilder builder = null;
        if(user.isPresent()) {// 이하의 실행문이 실행된다면 user에 AppUser 객체가 있다는 의이
            // -> 아직 user는 Optional 자료형이기 때문
            AppUser currentUser = user.get(); // optional에서 제네릭으로 존재하는 객체를 빼내는 메서드가 .get()
            builder = User.withUsername(username); // 정적 메서드
            builder.password(currentUser.getPassword())
                    .roles(currentUser.getRole()); // AppUser에 @Data를 달아놨다 = getter가 있으니 오류가 안난다.
            //builder.roles(currentUser.getRole()); 위에 채이닝 메서드로 연결해줬다.
            //참고로 builder = 부터 이을 수 있다.
        } else {
            throw new UsernameNotFoundException("해당 username을 가진 사용자를 찾지 못했습니다.");
        }
        return builder.build();
    }

}
```

 - Impl이란 무엇인가, implement의 약자이다.
 - `인터페이스명+Impl`을 기준으로 작성한다. 즉, UserDetailsService라는 인터페이스의 추상 메서드를 구현한 클래스라서 UserDetailsServiceImpl이 되는것이다.
 - loadUserByUsername() 메서드 내부에서 AppUser 클래스의 인스턴스인 user(객체명임)를 그대로 쓰는것이 아니라 UserBuilder라고 가지고 와서 선언하고, 거기서 AppUser의 field의 값들을 하나씩 대입한뒤 return 했다.
 - 이는 인터페이스의 정의를 명확하게 알지 못하면 효율적이지 못한 코드로 해석될 여지가 있다.
 `인터페이스는 추상메서드만 존재한다.` 그리고 이를 구현하는 클래스는 인터페이스 내에 있는 추상 메서드들을 강제로 구현해야한다.
 <br>
 우리가 AppUser라고 하는 엔티티 클래스를 만들기 이전에 인터페이스가 존재했고 , 이를 구현했으니 추상 메서드들의 return type은 AppUser가 될 수 없다.
 - 또한 다른 개발자들도 이 인터페이스를 그대로 갖다 쓸 것이기 때문에 자료형에 대한 보편적인 폼이 존재해야만 한다. 그렇게 추상 메서드인 loadUserByUsername의 return 타입이 고정되어 있음으로 우리는 우리가 만든 엔티티 클래스의 객체를 UserDetails 클래스의 객체 형태로 대입해주는 과정을 거쳐야만 한다. 그래서 if문 내부의 실행문에서 대입 로직이 존재하게 된다. else는 당연히 일치하는 AppUser가 없다는 뜻이므로 예외처리를 하게된다.

 - 이후는 스프링 시큐리티가 인메모리 사용자 대신에 방금 만든 AppUser관련 데이터베이스의 사용자를 참조하게끔 코드를 수정할 예정이다.

- 기능들 전부 구현한뒤 로그인을 만드는게 좋다, 아니면 번거롭다.

```java
package com.korit2.cardatabase.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService(){
        UserDetails user = User.builder()//빌더 패턴으로 객체생성, 즉 필드명과 값을 명시적으로 넣을 수 있다.
                .username("user")
                .password(passwordEncoder().encode("password")) // 비번 고정
                .roles("USER") // 역할 기반 보안, 일반 사용자의 경우
                .build();
        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

```

- bcrypt는 닐스 프로보스, 데이비드 마지에르가 설계한 해싱함수이다.
- `$2a`는 알고리즘 버전을 의미하고, `$12`는 알고리즘 강도를 나타낸다. 그리고 Spring Security 상에서의 BcryptPAsswordEncoder의 기본 강도는 10으로 되어있다.

- 검색해서 비밀번호가 안나오게 하는 법

```json
{
    "_embedded": {
        "appUsers": [
            {
                "username": "user",
                "password": "$2a$12$HFggwalNZTDPzdgnWtMW0evUaFe.pKQu6LrsOun16nmT7LXMvQT8O",
                "role": "User",
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/appUsers/1"
                    },
                    "appUser": {
                        "href": "http://localhost:8080/api/appUsers/1"
                    }
                }
            },
            {
                "username": "admin",
                "password": "$2a$12$C7sizbU7Qgewp8xsCscZxO5bqp5Z2ViXHSxZbYizswrA5yxuQ/0cy",
                "role": "Admin",
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/appUsers/2"
                    },
                    "appUser": {
                        "href": "http://localhost:8080/api/appUsers/2"
                    }
                }
            }
        ]
    },
    "_links": {
        "self": {
            "href": "http://localhost:8080/api/appUsers?page=0&size=20"
        },
        "profile": {
            "href": "http://localhost:8080/api/profile/appUsers"
        },
        "search": {
            "href": "http://localhost:8080/api/appUsers/search"
        }
    },
    "page": {
        "size": 20,
        "totalElements": 2,
        "totalPages": 1,
        "number": 0
    }
}
```
- 자기가 로그인만 되어있으면 다른 사람의 비번도 알 수 있다.

- 그래서 AppUserRepository를 통해서 요청을 날리지 못하도록 설정해야겠다.<br>
그리고 이는 Spring Data REST 때문에 자동으로 AppUser 관련 엔드포인트가 생성되었기 때문이다.

```java
  @RepositoryRestResource(exported = false) // 다른곳에 방출시키지 않겠다
```

![alt text](image-5.png)

더 이상 AppUser가 안나오는 것을 알 수 있다.